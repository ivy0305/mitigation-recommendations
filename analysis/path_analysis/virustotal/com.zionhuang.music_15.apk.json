{
  "data": {
    "Zenbox Linux": {
      "tactics": [
        {
          "description": "The adversary is trying to maintain their foothold.\n\nPersistence consists of techniques that adversaries use to keep access to systems across restarts, changed credentials, and other interruptions that could cut off their access. Techniques used for persistence include any access, action, or configuration changes that let them maintain their foothold on systems, such as replacing or hijacking legitimate code or adding startup code. ",
          "techniques": [
            {
              "description": "Adversaries may create or modify systemd services to repeatedly execute malicious payloads as part of persistence. Systemd is a system and service manager commonly used for managing background daemon processes (also known as services) and other system resources. Systemd is the default initialization (init) system on many Linux distributions replacing legacy init systems, including SysVinit and Upstart, while remaining backwards compatible.  \nSystemd utilizes unit configuration files with the .service file extension to encode information about a service's process. By default, system level unit files are stored in the /systemd/system directory of the root owned directories (/). User level unit files are stored in the /systemd/user directories of the user owned directories ($HOME).  \nService unit files use the following directives to execute system commands:  \n\nExecStart, ExecStartPre, and ExecStartPost directives cover execution of commands when a service is started manually by systemctl, or on system start if the service is set to automatically start.\nExecReload directive covers when a service restarts. \nExecStop, ExecStopPre, and ExecStopPost directives cover when a service is stopped.  \n\nAdversaries may abuse systemd functionality to establish persistent access to victim systems by creating and/or modifying service unit files systemd uses upon reboot or starting a service. Adversaries may also place symbolic links in these directories, enabling systemd to find these payloads regardless of where they reside on the filesystem.\nThe .service file\u2019s User directive can be used to run service as a specific user, which could result in privilege escalation based on specific user/group permissions. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Executes the \"systemctl\" command used for controlling the systemd system and service manager"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1543/002/",
              "id": "T1543.002",
              "name": "Systemd Service"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0003/",
          "id": "TA0003",
          "name": "Persistence"
        },
        {
          "description": "The adversary is trying to run malicious code.\n\nExecution consists of techniques that result in adversary-controlled code running on a local or remote system. Techniques that run malicious code are often paired with techniques from all other tactics to achieve broader goals, like exploring a network or stealing data. For example, an adversary might use a remote access tool to run a PowerShell script that does Remote System Discovery. ",
          "techniques": [
            {
              "description": "This technique has been deprecated. Please use Command and Scripting Interpreter where appropriate.\nAdversaries may use scripts to aid in operations and perform multiple actions that would otherwise be manual. Scripting is useful for speeding up operational tasks and reducing the time required to gain access to critical resources. Some scripting languages may be used to bypass process monitoring mechanisms by directly interacting with the operating system at an API level instead of calling other programs. Common scripting languages for Windows include VBScript and PowerShell but could also be in the form of command-line batch scripts.\nScripts can be embedded inside Office documents as macros that can be set to execute when files used in Spearphishing Attachment and other types of spearphishing are opened. Malicious embedded macros are an alternative means of execution than software exploitation through Exploitation for Client Execution, where adversaries will rely on macros being allowed or that the user will accept to activate them.\nMany popular offensive frameworks exist which use forms of scripting for security testers and adversaries alike. Metasploit , Veil , and PowerSploit  are three examples that are popular among penetration testers for exploit and post-compromise operations and include many features for evading defenses. Some adversaries are known to use PowerShell. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Executes commands using a shell command-line interpreter"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1064/",
              "id": "T1064",
              "name": "Scripting"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0002/",
          "id": "TA0002",
          "name": "Execution"
        },
        {
          "description": "The adversary is trying to figure out your environment.\n\nDiscovery consists of techniques an adversary may use to gain knowledge about the system and internal network. These techniques help adversaries observe the environment and orient themselves before deciding how to act. They also allow adversaries to explore what they can control and what\u2019s around their entry point in order to discover how it could benefit their current objective. Native operating system tools are often used toward this post-compromise information-gathering objective. ",
          "techniques": [
            {
              "description": "An adversary may attempt to get detailed information about the operating system and hardware, including version, patches, hotfixes, service packs, and architecture. Adversaries may use the information from System Information Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.\nTools such as Systeminfo can be used to gather detailed system information. If running with privileged access, a breakdown of system data can be gathered through the systemsetup configuration tool on macOS. As an example, adversaries with user-level access can execute the df -aH command to obtain currently mounted disks and associated freely available space. Adversaries may also leverage a Network Device CLI on network devices to gather detailed system information (e.g. show version). System Information Discovery combined with information gathered from other forms of discovery and reconnaissance can drive payload development and concealment.\nInfrastructure as a Service (IaaS) cloud providers such as AWS, GCP, and Azure allow access to instance and virtual machine information via APIs. Successful authenticated API calls can return data such as the operating system platform and status of a particular instance or the model view of a virtual machine.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Executes the \"uname\" command used to read OS and architecture name"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1082/",
              "id": "T1082",
              "name": "System Information Discovery"
            },
            {
              "description": "Adversaries may attempt to get a listing of security software, configurations, defensive tools, and sensors that are installed on a system or in a cloud environment. This may include things such as firewall rules and anti-virus. Adversaries may use the information from Security Software Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.\nExample commands that can be used to obtain security software information are netsh, reg query with Reg, dir with cmd, and Tasklist, but other indicators of discovery behavior may be more specific to the type of software or security system the adversary is looking for. It is becoming more common to see macOS malware perform checks for LittleSnitch and KnockKnock software.\nAdversaries may also utilize cloud APIs to discover the configurations of firewall rules within an environment. For example, the permitted IP ranges, ports or user accounts for the inbound/outbound rules of security groups, virtual firewalls established within AWS for EC2 and/or VPC instances, can be revealed by the DescribeSecurityGroups action with various request parameters. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Uses the \"uname\" system call to query kernel version information (possible evasion)"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1518/001/",
              "id": "T1518.001",
              "name": "Security Software Discovery"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0007/",
          "id": "TA0007",
          "name": "Discovery"
        },
        {
          "description": "The adversary is trying to communicate with compromised systems to control them.\n\nCommand and Control consists of techniques that adversaries may use to communicate with systems under their control within a victim network. Adversaries commonly attempt to mimic normal, expected traffic to avoid detection. There are many ways an adversary can establish command and control with various levels of stealth depending on the victim\u2019s network structure and defenses.",
          "techniques": [
            {
              "description": "Adversaries may communicate using OSI application layer protocols to avoid detection/network filtering by blending in with existing traffic. Commands to the remote system, and often the results of those commands, will be embedded within the protocol traffic between the client and server. \nAdversaries may utilize many different protocols, including those used for web browsing, transferring files, electronic mail, or DNS. For connections that occur internally within an enclave (such as those between a proxy or pivot node and other nodes), commonly used protocols are SMB, SSH, or RDP. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Executes the \"wget\" command typically used for HTTP/S downloading"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1071/",
              "id": "T1071",
              "name": "Application Layer Protocol"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0011/",
          "id": "TA0011",
          "name": "Command and Control"
        },
        {
          "description": "The adversary is trying to avoid being detected.\n\nDefense Evasion consists of techniques that adversaries use to avoid detection throughout their compromise. Techniques used for defense evasion include uninstalling/disabling security software or obfuscating/encrypting data and scripts. Adversaries also leverage and abuse trusted processes to hide and masquerade their malware. Other tactics\u2019 techniques are cross-listed here when those techniques include the added benefit of subverting defenses. ",
          "techniques": [
            {
              "description": "Adversaries may delete or modify artifacts generated within systems to remove evidence of their presence or hinder defenses. Various artifacts may be created by an adversary or something that can be attributed to an adversary\u2019s actions. Typically these artifacts are used as defensive indicators related to monitored events, such as strings from downloaded files, logs that are generated from user actions, and other data analyzed by defenders. Location, format, and type of artifact (such as command or login history) are often specific to each platform.\nRemoval of these indicators may interfere with event collection, reporting, or other processes used to detect intrusion activity. This may compromise the integrity of security solutions by causing notable events to go unreported. This activity may also impede forensic analysis and incident response, due to lack of sufficient data to determine what occurred.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Deletes log files"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1070/",
              "id": "T1070",
              "name": "Indicator Removal"
            },
            {
              "description": "This technique has been deprecated. Please use Command and Scripting Interpreter where appropriate.\nAdversaries may use scripts to aid in operations and perform multiple actions that would otherwise be manual. Scripting is useful for speeding up operational tasks and reducing the time required to gain access to critical resources. Some scripting languages may be used to bypass process monitoring mechanisms by directly interacting with the operating system at an API level instead of calling other programs. Common scripting languages for Windows include VBScript and PowerShell but could also be in the form of command-line batch scripts.\nScripts can be embedded inside Office documents as macros that can be set to execute when files used in Spearphishing Attachment and other types of spearphishing are opened. Malicious embedded macros are an alternative means of execution than software exploitation through Exploitation for Client Execution, where adversaries will rely on macros being allowed or that the user will accept to activate them.\nMany popular offensive frameworks exist which use forms of scripting for security testers and adversaries alike. Metasploit , Veil , and PowerSploit  are three examples that are popular among penetration testers for exploit and post-compromise operations and include many features for evading defenses. Some adversaries are known to use PowerShell. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Executes commands using a shell command-line interpreter"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1064/",
              "id": "T1064",
              "name": "Scripting"
            },
            {
              "description": "Adversaries may delete files left behind by the actions of their intrusion activity. Malware, tools, or other non-native files dropped or created on a system by an adversary (ex: Ingress Tool Transfer) may leave traces to indicate to what was done within a network and how. Removal of these files can occur during an intrusion, or as part of a post-intrusion process to minimize the adversary's footprint.\nThere are tools available from the host operating system to perform cleanup, but adversaries may use other tools as well. Examples of built-in Command and Scripting Interpreter functions include del on Windows and rm or unlink on Linux and macOS.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Executes the \"rm\" command used to delete files or directories"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1070/004/",
              "id": "T1070.004",
              "name": "File Deletion"
            },
            {
              "description": "Adversaries may set files and directories to be hidden to evade detection mechanisms. To prevent normal users from accidentally changing special files on a system, most operating systems have the concept of a \u2018hidden\u2019 file. These files don\u2019t show up when a user browses the file system with a GUI or when using normal commands on the command line. Users must explicitly ask to show the hidden files either via a series of Graphical User Interface (GUI) prompts or with command line switches (dir /a for Windows and ls \u2013a for Linux and macOS).\nOn Linux and Mac, users can mark specific files as hidden simply by putting a \u201c.\u201d as the first character in the file or folder name   . Files and folders that start with a period, \u2018.\u2019, are by default hidden from being viewed in the Finder application and standard command-line utilities like \u201cls\u201d. Users must specifically change settings to have these files viewable.\nFiles on macOS can also be marked with the UF_HIDDEN flag which prevents them from being seen in Finder.app, but still allows them to be seen in Terminal.app . On Windows, users can mark specific files as hidden by using the attrib.exe binary. Many applications create these hidden files and folders to store information so that it doesn\u2019t clutter up the user\u2019s workspace. For example, SSH utilities create a .ssh folder that\u2019s hidden and contains the user\u2019s known hosts and keys.\nAdversaries can use this to their advantage to hide files and folders anywhere on the system and evading a typical user or system analysis that does not incorporate investigation of hidden files.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Creates hidden files, links and/or directories"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1564/001/",
              "id": "T1564.001",
              "name": "Hidden Files and Directories"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0005/",
          "id": "TA0005",
          "name": "Defense Evasion"
        },
        {
          "description": "The adversary is trying to gain higher-level permissions.\n\nPrivilege Escalation consists of techniques that adversaries use to gain higher-level permissions on a system or network. Adversaries can often enter and explore a network with unprivileged access but require elevated permissions to follow through on their objectives. Common approaches are to take advantage of system weaknesses, misconfigurations, and vulnerabilities. Examples of elevated access include: \n\n* SYSTEM/root level\n* local administrator\n* user account with admin-like access \n* user accounts with access to specific system or perform specific function\n\nThese techniques often overlap with Persistence techniques, as OS features that let an adversary persist can execute in an elevated context.  ",
          "techniques": [
            {
              "description": "Adversaries may create or modify systemd services to repeatedly execute malicious payloads as part of persistence. Systemd is a system and service manager commonly used for managing background daemon processes (also known as services) and other system resources. Systemd is the default initialization (init) system on many Linux distributions replacing legacy init systems, including SysVinit and Upstart, while remaining backwards compatible.  \nSystemd utilizes unit configuration files with the .service file extension to encode information about a service's process. By default, system level unit files are stored in the /systemd/system directory of the root owned directories (/). User level unit files are stored in the /systemd/user directories of the user owned directories ($HOME).  \nService unit files use the following directives to execute system commands:  \n\nExecStart, ExecStartPre, and ExecStartPost directives cover execution of commands when a service is started manually by systemctl, or on system start if the service is set to automatically start.\nExecReload directive covers when a service restarts. \nExecStop, ExecStopPre, and ExecStopPost directives cover when a service is stopped.  \n\nAdversaries may abuse systemd functionality to establish persistent access to victim systems by creating and/or modifying service unit files systemd uses upon reboot or starting a service. Adversaries may also place symbolic links in these directories, enabling systemd to find these payloads regardless of where they reside on the filesystem.\nThe .service file\u2019s User directive can be used to run service as a specific user, which could result in privilege escalation based on specific user/group permissions. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Executes the \"systemctl\" command used for controlling the systemd system and service manager"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1543/002/",
              "id": "T1543.002",
              "name": "Systemd Service"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0004/",
          "id": "TA0004",
          "name": "Privilege Escalation"
        }
      ]
    },
    "Zenbox android": {
      "tactics": [
        {
          "description": "The adversary is trying to figure out your environment.\n\nDiscovery consists of techniques that allow the adversary to gain knowledge about the characteristics of the mobile device and potentially other networked systems. When adversaries gain access to a new system, they must orient themselves to what they now have control of and what benefits operating from that system give to their current objective or overall goals during the intrusion. The operating system may provide capabilities that aid in this post-compromise information-gathering phase.",
          "techniques": [
            {
              "description": "Adversaries may track a device\u2019s physical location through use of standard operating system APIs via malicious or exploited applications on the compromised device. \nOn Android, applications holding the ACCESS_COAURSE_LOCATION or ACCESS_FINE_LOCATION permissions provide access to the device\u2019s physical location. On Android 10 and up, declaration of the ACCESS_BACKGROUND_LOCATION permission in an application\u2019s manifest will allow applications to request location access even when the application is running in the background. Some adversaries have utilized integration of Baidu map services to retrieve geographical location once the location access permissions had been obtained. \nOn iOS, applications must include the NSLocationWhenInUseUsageDescription, NSLocationAlwaysAndWhenInUseUsageDescription, and/or NSLocationAlwaysUsageDescription keys in their Info.plist file depending on the extent of requested access to location information. On iOS 8.0 and up, applications call requestWhenInUseAuthorization() to request access to location information when the application is in use or requestAlwaysAuthorization() to request access to location information regardless of whether the application is in use. With elevated privileges, an adversary may be able to access location data without explicit user consent with the com.apple.locationd.preauthorized entitlement key.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Queries the phones location (GPS)"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1430/",
              "id": "T1430",
              "name": "Location Tracking"
            },
            {
              "description": "Adversaries may attempt to get information about running processes on a device. Information obtained could be used to gain an understanding of common software/applications running on devices within a network. Adversaries may use the information from Process Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions. \nRecent Android security enhancements have made it more difficult to obtain a list of running processes. On Android 7 and later, there is no way for an application to obtain the process list without abusing elevated privileges. This is due to the Android kernel utilizing the hidepid mount feature. Prior to Android 7, applications could utilize the ps command or examine the /proc directory on the device. \nIn iOS, applications have previously been able to use the sysctl command to obtain a list of running processes. This functionality has been removed in later iOS versions. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Queries list of running processes/tasks"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1424/",
              "id": "T1424",
              "name": "Process Discovery"
            },
            {
              "description": "Adversaries may attempt to get a listing of network connections to or from the compromised device they are currently accessing or from remote systems by querying for information over the network. \nThis is typically accomplished by utilizing device APIs to collect information about nearby networks, such as Wi-Fi, Bluetooth, and cellular tower connections. On Android, this can be done by querying the respective APIs: \n\n\nWifiInfo for information about the current Wi-Fi connection, as well as nearby Wi-Fi networks. Querying the WiFiInfo API requires the application to hold the ACCESS_FINE_LOCATION permission. \n\n\nBluetoothAdapter for information about Bluetooth devices, which also requires the application to hold several permissions granted by the user at runtime. \n\n\nFor Android versions prior to Q, applications can use the TelephonyManager.getNeighboringCellInfo() method. For Q and later, applications can use the TelephonyManager.getAllCellInfo() method. Both methods require the application hold the ACCESS_FINE_LOCATION permission.\n\n",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Checks an internet connection is available"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1421/",
              "id": "T1421",
              "name": "System Network Connections Discovery"
            },
            {
              "description": "Adversaries may attempt to get detailed information about a device\u2019s operating system and hardware, including versions, patches, and architecture. Adversaries may use the information from System Information Discovery during automated discovery to shape follow-on behaviors, including whether or not to fully infects the target and/or attempts specific actions. \nOn Android, much of this information is programmatically accessible to applications through the android.os.Build class.  iOS is much more restrictive with what information is visible to applications. Typically, applications will only be able to query the device model and which version of iOS it is running. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Queries several sensitive phone informations"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1426/",
              "id": "T1426",
              "name": "System Information Discovery"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0032/",
          "id": "TA0032",
          "name": "Discovery"
        },
        {
          "description": " The adversary is trying to avoid being detected.\n\nDefense evasion consists of techniques an adversary may use to evade detection or avoid other defenses. Sometimes these actions are the same as or variations of techniques in other categories that have the added benefit of subverting a particular defense or mitigation. Defense evasion may be considered a set of attributes the adversary applies to all other phases of the operation.",
          "techniques": [
            {
              "description": "Adversaries may attempt to make a payload or file difficult to discover or analyze by encrypting, encoding, or otherwise obfuscating its contents on the device or in transit. This is common behavior that can be used across different platforms and the network to evade defenses. \nPayloads may be compressed, archived, or encrypted in order to avoid detection. These payloads may be used during Initial Access or later to mitigate detection. Portions of files can also be encoded to hide the plaintext strings that would otherwise help defenders with discovery. Payloads may also be split into separate, seemingly benign files that only reveal malicious functionality when reassembled. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Obfuscates method names"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1406/",
              "id": "T1406",
              "name": "Obfuscated Files or Information"
            },
            {
              "description": "Adversaries may wipe a device or delete individual files in order to manipulate external outcomes or hide activity. An application must have administrator access to fully wipe the device, while individual files may not require special permissions to delete depending on their storage location. \nStored data could include a variety of file formats, such as Office files, databases, stored emails, and custom file formats. The impact file deletion will have depends on the type of data as well as the goals and objectives of the adversary, but can include deleting update files to evade detection or deleting attacker-specified files for impact.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Lists and deletes files in the same context"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1447/",
              "id": "T1447",
              "name": "Delete Device Data"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0030/",
          "id": "TA0030",
          "name": "Defense Evasion"
        },
        {
          "description": "The adversary is trying to manipulate, interrupt, or destroy your devices and data.\n\nThe impact tactic consists of techniques used by the adversary to execute his or her mission objectives but that do not cleanly fit into another category such as Collection. Mission objectives vary based on each adversary's goals, but examples include toll fraud, destruction of device data, or locking the user out of his or her device until a ransom is paid.",
          "techniques": [
            {
              "description": "Adversaries may wipe a device or delete individual files in order to manipulate external outcomes or hide activity. An application must have administrator access to fully wipe the device, while individual files may not require special permissions to delete depending on their storage location. \nStored data could include a variety of file formats, such as Office files, databases, stored emails, and custom file formats. The impact file deletion will have depends on the type of data as well as the goals and objectives of the adversary, but can include deleting update files to evade detection or deleting attacker-specified files for impact.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Lists and deletes files in the same context"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1447/",
              "id": "T1447",
              "name": "Delete Device Data"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0034/",
          "id": "TA0034",
          "name": "Impact"
        },
        {
          "description": "The adversary is trying to gather data of interest to their goal.\n\nCollection consists of techniques used to identify and gather information, such as sensitive files, from a target network prior to exfiltration. This category also covers locations on a system or network where the adversary may look for information to exfiltrate.",
          "techniques": [
            {
              "description": "Adversaries may use device sensors to collect information about nearby networks, such as Wi-Fi and Bluetooth.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Checks an internet connection is available"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1507/",
              "id": "T1507",
              "name": "Network Information Discovery"
            },
            {
              "description": "Adversaries may track a device\u2019s physical location through use of standard operating system APIs via malicious or exploited applications on the compromised device. \nOn Android, applications holding the ACCESS_COAURSE_LOCATION or ACCESS_FINE_LOCATION permissions provide access to the device\u2019s physical location. On Android 10 and up, declaration of the ACCESS_BACKGROUND_LOCATION permission in an application\u2019s manifest will allow applications to request location access even when the application is running in the background. Some adversaries have utilized integration of Baidu map services to retrieve geographical location once the location access permissions had been obtained. \nOn iOS, applications must include the NSLocationWhenInUseUsageDescription, NSLocationAlwaysAndWhenInUseUsageDescription, and/or NSLocationAlwaysUsageDescription keys in their Info.plist file depending on the extent of requested access to location information. On iOS 8.0 and up, applications call requestWhenInUseAuthorization() to request access to location information when the application is in use or requestAlwaysAuthorization() to request access to location information regardless of whether the application is in use. With elevated privileges, an adversary may be able to access location data without explicit user consent with the com.apple.locationd.preauthorized entitlement key.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Queries the phones location (GPS)"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1430/",
              "id": "T1430",
              "name": "Location Tracking"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0035/",
          "id": "TA0035",
          "name": "Collection"
        },
        {
          "description": "The adversary is trying to intercept or manipulate network traffic to or from a device.\n\nThis category refers to network-based techniques that an adversary may be able to use to fulfill his or her objectives without access to the mobile device itself. These include techniques to intercept or manipulate network traffic to and from the mobile device.",
          "techniques": [
            {
              "description": "If network traffic between the mobile device and remote servers is unencrypted or is encrypted in an insecure manner, then an adversary positioned on the network can eavesdrop on communication.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Monitors network connection state"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1439/",
              "id": "T1439",
              "name": "Eavesdrop on Insecure Network Communication"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0038/",
          "id": "TA0038",
          "name": "Network Effects"
        },
        {
          "description": "The adversary is trying to communicate with compromised systems to control them.\n\nCommand and Control consists of techniques that adversaries may use to communicate with systems under their control within a victim network. Adversaries commonly attempt to mimic normal, expected traffic to avoid detection. There are many ways an adversary can establish command and control with various levels of stealth depending on the victim\u2019s network structure and defenses.",
          "techniques": [
            {
              "description": "Adversaries may communicate using OSI application layer protocols to avoid detection/network filtering by blending in with existing traffic. Commands to the remote system, and often the results of those commands, will be embedded within the protocol traffic between the client and server. \nAdversaries may utilize many different protocols, including those used for web browsing, transferring files, electronic mail, or DNS. For connections that occur internally within an enclave (such as those between a proxy or pivot node and other nodes), commonly used protocols are SMB, SSH, or RDP. ",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Performs DNS lookups"
                },
                {
                  "severity": "INFO",
                  "description": "Uses HTTPS"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1071/",
              "id": "T1071",
              "name": "Application Layer Protocol"
            },
            {
              "description": "Adversaries may use an OSI non-application layer protocol for communication between host and C2 server or among infected hosts within a network. The list of possible protocols is extensive. Specific examples include use of network layer protocols, such as the Internet Control Message Protocol (ICMP), transport layer protocols, such as the User Datagram Protocol (UDP), session layer protocols, such as Socket Secure (SOCKS), as well as redirected/tunneled protocols, such as Serial over LAN (SOL).\nICMP communication between hosts is one example. Because ICMP is part of the Internet Protocol Suite, it is required to be implemented by all IP-compatible hosts. However, it is not as commonly monitored as other Internet Protocols such as TCP or UDP and may be used by adversaries to hide communications.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Performs DNS lookups"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1095/",
              "id": "T1095",
              "name": "Non-Application Layer Protocol"
            },
            {
              "description": "Adversaries may employ a known encryption algorithm to conceal command and control traffic rather than relying on any inherent protections provided by a communication protocol. Despite the use of a secure algorithm, these implementations may be vulnerable to reverse engineering if secret keys are encoded and/or generated within malware samples/configuration files.",
              "signatures": [
                {
                  "severity": "INFO",
                  "description": "Uses HTTPS"
                }
              ],
              "link": "https://attack.mitre.org/techniques/T1573/",
              "id": "T1573",
              "name": "Encrypted Channel"
            }
          ],
          "link": "https://attack.mitre.org/tactics/TA0011/",
          "id": "TA0011",
          "name": "Command and Control"
        }
      ]
    }
  },
  "links": {
    "self": "https://www.virustotal.com/api/v3/files/45669ba09d03c737086c936bd463ee6d/behaviour_mitre_trees"
  },
  "md5": "45669ba09d03c737086c936bd463ee6d"
}